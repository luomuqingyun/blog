---
title: 计算机定点数解说
date: 2025-05-19 14:42:00
---

占位
## 回顾计算机中的数字
在学习计算机基础的过程中我们已经知道计算机是基于二进制对数据进行存储和运算的。学习C语言时我们又知道了C语言中常见的数据类型有:`char`,`int`,`long int`等 `signed` 或 `unsigned` 整数数据，以及`float`和`double`型的小数数据。或看过我之前文章的朋友肯定也明白了，无论使用何种语言编写的何种程序，最后进入处理器执行的都是一串二进制数据，是不是突然又想不明白处理器到底是怎么区分这些数据类型了？这不又绕回原来说的底层逻辑了吗，你学微机原理，学汇编指令不就是帮你解决这个问题的？回过头去研究明白了那以后何止单片机软件开发呢，芯片设计，系统、编译器开发不都能胜任了。扯远了，先回到正题。

在初中阶段我们就学习了使用科学计数法对数据进行处理，即$ N = M*J^E$。

比如: $12345 = 1.2345 * 10^4$

其实在计算机中同样是使用科学计数法进行存储数据的（实际为数据的补码形式），只不过这里的底数是2。

比如：十进制的`unsigned char` 数据4，二进制形式为`0000 0100`,即为$1*2^2 $。

对于带小数的数据也是如此，同样需要将十进制数据转为二进制，并规定其符号位，指数位以及小数位。比如IEEE.754标准（即IEEE二进制浮点数算术标准）中对`float`,`double`存储逻辑的规定：
|类型|总位数|符号位S|指数位E|尾数位F|
|:---:|:---:|:---:|:---:|:---:|
|float|32|1|8|23|
|double|64|1|11|52|

可以得出float数据$ N = (-1)^S * 1.F * 2^{E} $

## 定点数据
一般情况下我们会将有小数的数据称为浮点型数据，`float`为单精度浮点数据,`double`为双精度浮点数据。正如上面所说的我们计算机使用的是以浮点法保存小数型数据的。与之对应的肯定就会有以定点的方式保存小数数据的方法。

`定点`是指表示一个数值时，小数点之后的位数是固定的，有时候小数点之前的位数是固定的。上面用浮点表示的小数，小数点的位置不是固定的，可以根据有效位数而浮动。

![定点小数](https://files.mdnice.com/user/38598/9fbe247a-38a9-4395-91e3-70e1e3499f3e.png)

![定点整数](https://files.mdnice.com/user/38598/6037c610-ba9c-49c8-aaaf-6d023f4228bd.png)

定点数类型的值其实就是个整数，需要额外做比例进位，进多少位需要根据具体的定点数类型决定。例如 1.23 使用 1/1000 缩放系数的定点数表示时是 1230；1,230,000 使用 1000 缩放系数的定点数表示也是 1230。与浮点数不同，相同类型的定点数中所有值的缩放系数都是一致的，在计算过程中也保持不变。此表示法可以用标准的整数算术逻辑单元来进行有理数的计算。

为了效率考量，缩放系数（scaling factor）一般会是基数b（2 或是 10）的正幂次，或是负幂次，因此实际内部仍然可以用类似整数的方式处理。不过缩放系数也需依应用而定。因此许多的数字可能其数值其实是用二进制记录，但为了使用方便人类读写，缩放系数仍选择10的幂，10的幂的缩放系数也可以配合国际单位制，因为选择特定的缩放系数，可能相当于使用另外一个大小较适合的单位，例如使用厘米或微米，而不是使用米，或者是以1/3600为缩放系数的定点数来表示以小时为单位的时间值，精确到秒。

采用定点计数法时，相邻两个数之差总是等于其中一个数的值，而采用浮点计数法时，相邻数并不是均匀分布的。另外浮点计数的计数范围是比定点计数范围要大得多，并且一般场景中浮点计数精度往往也比定点计数精度高，正因为如此，一般情况下浮点计数法更适合于一般应用场景，所以我们对定点数感到陌生也完全不奇怪。所以现在大多数处理器芯片都是带有浮点运算器（FPU），只有在特殊的应用中才使用定点数运算，例如某些特定应用下的数字信号处理芯片（DSP）或一些低价的嵌入式系统微处理器（MCU），这类的应用强调高需求速度，低电力需求及小集成电路区域，例如影像、视频或图片等数字信号处理，进行傅里叶变换以及数字滤波器设计，或是其他一些这种数字表示法比较适合的场景，如货币计算，仪器测量计数等，这些都是有特定的精度规则，使用浮点计数反而可能带来更大的芯片资源消耗或成本开支，并且这些情况运算速度也不如定点运算快。

定点数中表示字长和二进制定点数中小数点位置的方法有很多种，比如：$Q_f$，$Q_{m.n}$，$fx_{m.b}$，$s:m:f$等等，其中 $Q_f$（Q格式）以及$Q_{m.n}$（无歧义Q格式）是比较常见的方法。
例如16位的定点数Q格式可以有以下表示方式：

| $Q$ | $Q_{m.n}$ | $Max$ | $Min$ |
|Q|Qmn|Max|Min|
|:---:|:---:|:---:|:---:|
|Q15| Q0.15 |0.999969 |-1.000000|
|Q14| Q1.14 |1.999939 |-2.000000|
|Q13| Q2.13 |3.999878 |-4.000000|
|Q12| Q3.12|7.999756 |-8.000000|
|Q11| Q4.11|15.999512 |-16.000000|
|Q10| Q5.10 |31.999023 |-32.000000|
|Q9| Q6.9 |63.998047 |-64.000000|
|Q8| Q7.8 |127.996094 |-128.000000|
|Q7| Q8.7 |255.992188 |-256.000000|
|Q6| Q9.6 |511.984375 |-512.000000|
|Q5| Q10.5 |1023.968750 |-1024.000000|
|Q4| Q11.4 |2047.937500 |-2048.000000|
|Q3| Q12.3 |4095.875000 |-4096.000000|
|Q2| Q13.2 |8191.750000 |-8192.000000|
|Q1| Q14.1 |16383.500000 |-16384.000000|
|Q0| Q15.0 |32767.000000 |-32768.000000|

当然平时使用时我们也可以编写一些特定程序对这些格式表示的数值范围进行验证。
```
#include <stdio.h>
#include <stdint.h>
#include <math.h>

int main()
{
    int16_t q_max = 32767; // 0x7FFF
    int16_t q_min = -32768; // 0x8000
    float f_max = 0;
    float f_min = 0;
    printf("\r\n");
    for (int8_t i = 15; i>=0; i--) 
    {
        f_max = (float)q_max / pow(2,i);
        f_min = (float)q_min / pow(2,i);

        printf("\t|Q%d\t|Q%d.%d\t|%f\t|%f\t|\r\n",
               i,(15-i),i,f_max,f_min);
    }
    return 0;
}
```

![打印结果](https://files.mdnice.com/user/38598/7808f4fa-6fe1-49dc-802a-272f0d703ad1.png)

## 定点与浮点相互转化
在一些功能复杂的处理器中会同时支持两种数据处理方式，比如STM32G4系列的芯片上携带的`FMAC(filtermath accelerator)`支持的定点DSP处理功能，使用的定点格式为Q1.15。

在这种既有定点运算又有浮点运算是处理器上做开发时我们不可避免的都会涉及到定点与浮点相互转化的问题，这时需要注意进行处理数据！
> 浮点数到Q格式  
> 若要将浮点数（例如IEEE 754）转换为$Q_{m.n}$的格式：  
>> 1. 将浮点数乘以$2^n$   
>> 2. 四舍五入到最接近的整数    

> Q格式到浮点数  
> 若要将$Q_{m.n}$的Q格式的数数转换为浮点数：
>> 1.将整数转换为浮点数   
>> 2.乘以$2^{−n}$

## 定点运算思的扩展
在某些特定情况下定点运算对算法的效率优化有着出奇的效果，如果你对这方面感兴趣不妨可以研究一下经典的`快速平方根算法`。

另外，我们平时做单片机开发时在一些比较低端的芯片中，比如C51单片机，请切记不要轻易使用浮点运算！如果需要进行小数运算，我们可以借助定点运算是思想在程序中通过设计一定的比例系数对数据进行放大或缩小处理，从而实现某些功能。不要问我为啥，举个简单的例子，利用超声波模块测距，你自己写两个程序，一个使用浮点，一个不使用做个实验测试一下就可以知道结果是怎么的了。

#### 推荐阅读
- [51单片机入门看这一篇就够了](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485523&idx=1&sn=b7fcd1b86e2467d6f03b1a520c39bb06&chksm=ea790022dd0e893452c4994fa16d63111b16d9878c303712f695b58b7af360b7b18c1ed4b201&token=1711068967&lang=zh_CN#rd)
- [怎么快速上手一款新的MCU](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485581&idx=1&sn=b36e6536717774f7931c7aa93d5b237a&chksm=ea7900fcdd0e89ea0db13737720edc996fcb3fdbab3e43b4a92316240ac66d4b5a8bf9a07e78&token=466212876&lang=zh_CN#rd)
- [Keil软件如何高效格式化代码](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485572&idx=1&sn=17cefa35d9d660083d419a7e9b6db6f7&chksm=ea7900f5dd0e89e35b65ba26354cc69ad24f686d8e18abd34e0932567a9345e8c9ed653eee6b&token=1711068967&lang=zh_CN#rd)
- [分享几个windows平台上非常实用的工具](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485420&idx=2&sn=728ca4abbadf7caf51c392e7d7045cbe&chksm=ea790f9ddd0e868b9fa162c80db1876199845f387bbe851c8d38a4e8412329ae635916c13cfb&token=1711068967&lang=zh_CN#rd)
- [实用单片机、电子开发小工具集](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485606&idx=1&sn=2b433faa2e436fc762dc538c9cf3fe14&chksm=ea7900d7dd0e89c169f8948ff3d423016c8f51f1c914eb7b0d20cba8145b9ffa54815915d67b&token=1580674001&lang=zh_CN#rd)
- [零基础电子技术知识集合](https://mp.weixin.qq.com/s?__biz=MzI1OTQ4MTg4Ng==&mid=2247485689&idx=4&sn=211c2d0871a19c5e92cdf0c34f01d96b&chksm=ea790088dd0e899e3042a649a346bc98e94189d1fd18da2b954a7ddb781582dc2d0a82e07f4d&token=970763775&lang=zh_CN#rd)
----

![欢迎添加作者微信，加入交流群](https://files.mdnice.com/user/38598/37e7b97e-a5c7-44d1-9e48-bbe22ab3141d.jpg)

----
部分分享的资料链接在交流群公告中，如果要进群，加好友时记得备注信息`进群`。